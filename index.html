<!DOCTYPE html>
<html lang="en" role="main">
<script>
	const st = performance.now();
</script>
<head>
	<!-- Proud human written website -->
	<meta charset="UTF-8">
	<meta name="description" content="My portfolio wesite">
	<meta name="keywords" content="project, portfolio, 9jh1, _3hy, 3hy, coding, programming.">
  <meta name="author" content="9jh1">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">

	<link rel="icon" type="image/png", href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEVHcEyC+tLSAAAAAXRSTlMAQObYZgAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII=">
	<title>Untitled Website #9</title>
	
	<script title="public.js">	
		function format_time(date) {
			let ms = Math.floor((Date.now() - date.getTime()) / 1000);

			const units = [
				{ label: "d", secs: 86400 },
				{ label: "h", secs: 3600 },
				{ label: "m", secs: 60 },
				{ label: "s", secs: 1 }
			];

			let str = "";
			for (const { label, secs } of units) {
				const val = Math.floor(ms / secs);
				if (val > 0) {
					str += `${val}${label} `;
					ms %= secs;
			}
			if (str) break;
		}

		return (str || "0s").trim() + " ago";
	}

	// Initialize on page load
	window.onload = function() {
		const url = new URLSearchParams(window.location.search);
	
		document.querySelectorAll(".utc").forEach(element=>{
			const time = new Date(element.innerText);
			element.title = time;
			element.innerHTML = format_time(time);
		})

		// Load post URL
		if(url.has("p")){
			fetch('src/data.json')
				.then(res => {
					return res.json();
				})
				.then(data => {
					document.head.innerHTML = "";
					document.body.innerHTML = "404";
					if (Number(url.get("p")) < data["journal"].length) {
						const loc = data["journal"][url.get("p")];
						document.body.innerText = `title  : ${loc.title}\ntags   : ${loc.tags.join(", ")}\ndate   : ${loc.date}\nposted : ${format_time(new Date(loc.date))}\nurl    : ${location.href}\n${"-".repeat(20)}\n${loc.content}`;
					}
			})
		}
	}
	</script>
	<style>
		* {
			font-family: monospace;
			font-size: 16px;
			text-wrap: wrap;
			margin: 0px;
			padding:0px;
			box-sizing: border-box;
		}

		body {
			background: black;
			max-width:50%;
			color:white;
		}

		pre {
			background: rgba(255,255,255,0.1);
			color: white;
			width:100%;
		}

		body, pre {
			padding: 0px 2ch;
		}

		a { 
			color:cyan;
		}

		.journal_dropdown {
			height:2ch;
			overflow:hidden;
		}

		.journal_dropdown:hover {
			height:fit-content;
			overflow:hidden;
		}

		@media screen and (orientation: portrait){
			* {
				font-size: 10px;
			}
			body {
				max-width:100%;
				width: 100%;
			}
		}
	</style>
</head>
<body role="document">
	<br>
	<i role="blockquote">
		<div>I want my office to be quiet. The loudest thing in the room by far should be the occasional purring of the cat</div>
		<div>- Linus Torvalds</div>	
	</i>
	<br>
	<hr>
	<br>
	<b>About Me:</b>
	<div>I'm an experienced C developer, I've been writing open source, free and optimized software for the last 5 years.</div>
	<br>
	<div>I love free (<i>as in freedom</i>) open source software and community driven projects. Some of my favorite software is made by <a href="https://suckless.org/">suckless software</a> and <a href="https://www.gnu.org/home.en.html">GNU tools</a>. I value privacy over everything, I despise subscription services. The modern digital world is a mess, having to navigate surveillance, censorship, capitalism, and the ever increasing use of artificial intelligence. Put the power back in the hands of the people.</div>
	<br>
	<div> Over the years I've used many different operating systems, Linux, BSD, Windows and more linux. I love the idea that everything on my system is installed and manually managed by me. Currently I daily drive <i>SalixOS</i> which is a distribution based on Slackware - the oldest maintained Linux distro. Personally I like a system that I can install easily but spent ages and ages configuring, take FreeBSD for example, super simple 10 minute installation process but it took me over 20 hours to get my graphics and display drivers working.</div>
	<br>
	<div>Try my configs: <a href="https://github.com/9jh1/nvim">neovim</a>, <a href="https://github.com/9jh1/i3-lite">i3</a> and <a href="https://github.com/9jh1/dwm-rice">dwm</a>.</div>
	<br>
	<hr>
	<br>
	<b>Projects:</b>
<pre><br>name    : xobar
tags    : c, opensource, tomlc, xobar, depricated
tagline : Status bar
url     : <a href="https://github.com/9JH1/xobar">https://github.com/9JH1/xobar</a>
--------------------
Custom text statusbar. Made as a replacement for i3status.
Uses the tomlc library to parse a toml configuration file
<br></pre>
<br>
<pre><br>name    : Auto Read-Run(er)
tags    : c, opensource, gnu, arr
tagline : Ansi C
url     : <a href="https://github.com/9jh1/arr">https://github.com/9jh1/arr</a>
--------------------
<span class="file-list">arr.c, </span>Takes in a file and watches its contense, if the contense changes it runs a given command.
<br></pre>
<br>
<pre><br>name    : PLib
tags    : c, opensource, library, plib
tagline : Ansi C library
url     : <a href="https://github.com/9jh1/plib">https://github.com/9jh1/plib</a>
--------------------
<span class="file-list">plib.c, plib.h, </span>Simple argument parsing that allows you to easily set up your program without the need for bulky and ugly loops and else if blocks.
<span class="file-list">lib/input.c, lib/input.h, </span>Basic non-threaded input loop that allows for not just regular keys but all mouse input (SCROLL, MOVE, RELEASE) along with a few special keys eg Control+G.
<span class="file-list">lib/input.c, lib.input.h, </span>Optimised styled box renderer that allows you to draw a box onto the screen at any point. this is bundled with the input loop code as you can easily set up input detection on boxes using it.
<br></pre>
<br>
	<!-- PROJECT_START -->
	<hr>
	<br>
	<b>Contact me:</b>
	<div>I'm available for discussion, review or feedback. If you are looking to hire me for a task, email me and use the keyword <i>job</i> anywhere in the subject line. I should get back to you within one business day <b>AUST</b>. The following email forwards to my personal <i><a href="disroot.org">Disroot.org</a></i> account, If you attempt to contact me via any other means other then this email, your message will be <b>ignored</b>.</div>
	<br>
	<i role="group">
		<div><a href="mailto:tkf.x1os@gmail.com">tkf.x1os@gmail.com</a></div>
	</i>
	<br>
	<hr>
	<br>
	<div class="journal_dropdown">
		<p><b>Journal:</b> <i>(Hover to view)</i></p>
		<p>These derive into ramblings. Sorry :3.</p>
	
<pre><br>title  : <a href="?p=5">How I layout my projects.</a>
tags   : 
posted : <span class="utc">2025-12-16T09:33:23Z</span>
date   : 2025-12-16T09:33:23Z
--------------------
I am a very organized person, annoyingly I struggle to keep the same consitency in my code. For a long time my code was very jumbled and after a week I'd forget most of what was written and end up giving up on the project. 

This guide does not go over licencing, hosting or how to get user feedback. That is all up to you.

Another thing to note is that this is all from PERSONAL EXPERIENCE and if you find a stage or step to be strange or backwards then go ahead and take some initiative by using another idea.

STAGE ONE: Design. 
First thing when creating a project is the idea, Create a IDEA.md file and write down the projects description and how you think it would work, Optionally provide insights onto what dependancies may be used to create certain parts of the program.. Once you are happy with your TODO.md file create an additional README.md file and write up the information that you think a user would need to know before using your project, keep in mind this can just be a rough wireframe. You might wonder why the README is one of the first files you create, the reason for this is that I've found when writing the README.md and thinking from a users perspective, I notice things that I might have missed in the code like missing quality-of-life features or a messy installation process. Once you're happy with your README file I'd suggest showing the files to your manager or a coworker to see if brand new eyes can spot something you may have missed. It is important to know what you're getting into BEFORE you start the project. All of this is to ensure that the project stays alive for as long as possible.


STAGE TWO: Prototyping 1.
The next thing you should focus on is creating a basic mock-up of your program. If for example your project is a new website maybe open up Figma and draw up a proper mock-up of every page you might have. While doing this you can add more documentation to your IDEA.md file. At this stage you can again get feedback from other people for the same reasons as before. The next step would be Layout design which comes inbetween the prototypeing stage. This is generally up to personal preferance but I like to have my files setup like so 
--------------------------------------
src/
	+ remote/
		- Cloned librarys for use in 
		  the project. eg Plib, cJSON.

	+ static/
		- Static library files unique 
		  to the project. 

	+ build/
		+ compile.sh
			- Compilation script and 
			  other utilitys can go 
			  in here.

main
	- Main file, alternativly could 
	  be index or whatever your 
	  project requires.

appname 
	- This can be a symbolic link to 
	  your compile.sh file.
	
IDEA.md
README.md 
-------------------------------------

Optionally along with this file layout aditional folders like TESTS or BUILDS could also be included, of course this is completly up to you the developer but I strongly suggest sticking to a consitent layout scheme accross projects, and again this layout can be addapted to project requirements.


STAGE THREE: Prototyping 2.
This stage is where you start to get the idea onto a funcional mock-up. If you where designing a terminal CLI program maybe write up a version of it in a basic form to ensure that a feature may work as intended. Any files associated from this stage can be kept in a folder called TESTS like mentioned in PROTOTYPING 1. I strongly suggest doing at least one proof of concept test for all of the more advanced features. Recently I've been working on a new version of motionlayer, my X11 video wallpaper program. When I first started writing the code for this project I dident know if any of the features I had in mind would work, eg Fullscreen program detection and background mpv daemon control. I ended up writing a concept implementation of those features to ensure I'd know the constraints and dependancies before actually writing the entire program in whole. It is crucial that you get feedback on your final mock up, at this stage you havent developed a full-blown application yet and so there is still time to tweak the blueprint you have constructed so far.


STAGE FOUR: Intergration. 
Now that you have a working proof-of-concept you can begin writing the actual program.. I'd strongly suggest against using the mock-up code as a boilerplate for the final project as I've noticed having to re-write the code from scratch resulted in better structured code and I noticed a few things that I could improove on from prototyping that I can now implement. Ensure that you are properly documenting you code.. I'd suggest using Doxygen or another form of docs generator program as in-file documentation can be hard for a user to read and usually a generated website is more accessable for you the developer to then forward onto your projects website. Documentation is also important to reduce any chance of you coming back to the project and forgetting how everything works and then having to re-write the entire codebase. Use the README.md and IDEA.MD files as a todo list until all features have been correctly implemented.

STAGE FIVE: Refining. 
This stage is very straightforward.. Now that you have a project its time to test it.. You could of course do this yourself or if you're feeling a bit more chaotic you could push your untested code and whack a big ol WIP badge or a UNDER MAINTAINANCE banner on your README or project website and boom! Let the users find the bugs and boom less work for you.. Now you might be thinking how on earth am I gonna stay on top of all that feedback?? Well bucko don't get ahead of yourself are you really that popular? In all seriousness you could easily limit the amount of users using your project to limit the stain of new issues. Of course as soon as you can release your program to the general public. 

And done! Make sure you include a layout guide similar to this one inside your project to teach future maintainers how to properly maintain your project.

<br></pre>
<br>
<pre><br>title  : <a href="?p=4">I Use Arch BTW</a>
tags   : 
posted : <span class="utc">2025-12-14T10:48:32Z</span>
date   : 2025-12-14T10:48:32Z
--------------------
The title is a joke cowboy.. calm down.

I've been using Archlinux for quite a while now.. 3 years. I recently decided that Archlinux is far too mainstream and so I set out on finding a new OS that could fit my needs as a developer. As a developer I like to have the most up-to-date packages along with quick installation of said packages. When I install an OS I like it to have either a quick and easy setup but a long post-install setup (think BSD) OR a very advanced setup and some other features that make it worth my time. 

Don't take my last statement as me saying I dislike installing advanced systems, just imagine I want to quickly re-install my development environment onto a new device or from a reinstall, I don't want to have to spend hours compiling the kernal or configuring locales.

Now the first OS set I tried was BSD based systems. The few I tried where
- OpenBSD
- FreeBSD
- NetBSD
(in order)

Now OpenBSD was really nice when installing, just like the other BSD varients it had a very basic installation process using a TUI setup process. I found all of the BSD versions very enjoyable to install. After first installing OpenBSD it prompty took 30 minutes to boot. This was likely due to the fact that OpenBSD is very secure and it performs several memory checks and other system checks on boot, the other more likely reason was that it was the first boot. FreeBSD had about the same installation process give or take, I will say FreeBSD was the only BSD version that I had looked into before. FreeBSD was the next OS I installed, Now I ended up cutting my visit short due to FreeBSD's lack of support for my Realtek ethernet driver, this was because I had downloaded the bootonly option which dosent actually come with full driver support so really this was my fault but don't worry I came back to give it another shot. Now NetBSD was cool and all and it was the first BSD version I actually got to boot, I played around with the default X11 environment before trying to fix the very apparent issue with the lack of graphics drivers which caused X11 to be in 1260x680p which is not ideal on a 1920x1080p monitor.. After some googling I found out that NetBSD dident even have a package for the drivers I needed. I switched back to FreeBSD and figured out how to install graphics drivers. I gotta say FreeBSD was a great system to use. Sure packages where annoying to install but it was a sacrafice I was willing to take. My computer is used for two things and two things only, One being development but two being playing games with my friends. I was a bit disapointed that there is no simple BSD alternative build for either Discord or Steam and the few that where available where buggy and complicated, and I'm far to stupid to even attempt such things.

I decided to push the lack of support aside and do some developing just to see if the development experience could make up for it. I like to develop in my own custom environment built offof sucklesses window manager. At the time my configuration used polybar which is a popular lightweight statusbar program, this and a few other dependancies are required for my build to work. I spent an aditional Day installing polybar and the other dependancies and found that the package manager provided was so outdated that I ended up having to manually install from source every time I wanted something up to date. Now again like I said before I have no issue with compiling things myself its no hardship just the time crunch is not acceptable when I'm busy and need a package fast.

Now after all of the BSD stuff I started looking into more advanced linux distros. a few that caught my eye where Gentoo and Slackware. First I tried slackware before figuring out the absolutly useless package manager and pre-installed bloat so I immediatly to SalixOS which is built ontop of slackware but also has a more usable backage manager slapt-get. I used slackware for a little until I ran into the same problem as before where packages where outdated and some where just not available. More infuriating Slackware has an online user driven repository of source packages that let you download a packages source code along with a file which can be used to compile the program. This system just reminded me of the arch AUR and PKGBUILDs. Now the issue with this slackware system is that packages are not maintained at all so it was common to find packages that EXISTED but where just uninstallable, and of course this meant installing from source and compiling manually.. nice stuff. Next on the list was Gentoo which was a day long commute to install. Gentoo comes with Systemd which is nice.. uh yeah but guess what the package manager is a compile local package mananger so when installing a package you run a very basic command, yes yes good good, then you wait 20 buisness days for it to download the source and all the dependancies before locally compiling and installing.. holy moly what a waste of time. 

I'm very sure that it was me that was making these issues so apparent and I'm sure there are millions of alternative routes I could have taken. I've ended up back with arch linux which i guess solved my issue with it being mainstream.. it is mainstream because it is so easy to install now-a-days so every idiot installs it just to say they use linux while running a base kde or gnome setup. I absolultly hate those kinds of people who use something for the main reason of status or reputation.. This was the initial reason I wanted to move over to another OS. I wanted an OS that was not diluted and poisoned by outliers in the community. I guess this week long journey has given me proof that I have an actual reason to be using arch. After all that fuss I think arch is the best distro because it has both up-to-date packages and a comprehensive installation and customization process.

<br></pre>
<br>
<pre><br>title  : <a href="?p=3">ew protonmail</a>
tags   : privacy, usability, rant
posted : <span class="utc">2025-12-04T00:03:53Z</span>
date   : 2025-12-04T00:03:53Z
--------------------
I've been using proton mail for a few months now, and don't get me wrong I like proton as a company and I understand that they're just trying to make some funding. Personally I'm not a big fan of the corperate presence thats becoming the norm. Now I like to use the aerc email client, small issue with this, proton dosent allow users to use clients other then their offical client.. The only way theyve provided to negate this is to have a proton-mail-plus subscription AND a desktop application (protonmail-bridge-core) which acts as the other end of the encryption that way the client using the proton email can actually read emails..

I have no issue with some features being behind a paywall again proton do need to make some money somehow but this is such a basic feature..

To fix this issue I've created a new email at disroot.org which provides end-to-end symetric encryption using pgp, disroot.org also supports 3rd party clients out of the box. I've set up my accounts so that my proton account forwards emails to my disroot account but in doing so I also noticed that proton does not forward emails sent from its own address so emails sent from your own email to yourself will not be forewarded.. ill also say that there are very few options given to actually change the forwarding settings.. In gmail the options to delete, archive or keep forwarded mail is right there but in proton no such feature exists. Ontop of all of this disroot also has a contact book system that allows you to import your contacts from other services eg google contacts, this is yet another feature that protonmail does not have.

This website still shows a google email as a contact email all emails sent to that address will be forwarded to my disroot email. go check out disroot.org, note that they are donation run and therefore have limited time and because of this they close registrations during the weekend. After signing up you have a 48 hour period where a maintainer will have to manually approve your account request. There is no mention of the prior when signing up.
EDIT, recently email forwarding was disabled as it is now a premium service!
<br></pre>
<br>
<pre><br>title  : <a href="?p=2">Link Sharing!!</a>
tags   : notopic
posted : <span class="utc">2025-12-02T10:45:42Z</span>
date   : 2025-12-02T10:45:42Z
--------------------
This page now supports sharing of specific journal entries!!
Try it out by pressing the text below:
EDIT* after updates you can now click on the title of the page to go to the unique post url, this url can be shared.
<br></pre>
<br>
<pre><br>title  : <a href="?p=1">New projects</a>
tags   : projects, wip, c, navtui, 0bchat
posted : <span class="utc">2025-12-02T01:23:06.100Z</span>
date   : 2025-12-02T01:23:06.100Z
--------------------
I've started development on 0bchat - A end to end encrypted chat client using C. With PLib V5.0.1 I've started writing navtui, a navidrome client terminal application, both of these projects are privated at the moment but will go public on their first release. I don't want another incident with unfinished repos ehm motionlayer..
<br></pre>
<br>
<pre><br>title  : <a href="?p=0">Initial Commit</a>
tags   : notopic
posted : <span class="utc">2025-12-01T23:20:19.976Z</span>
date   : 2025-12-01T23:20:19.976Z
--------------------
Hello World!
Welcome to my new website!
<br></pre>
<br>
		<!-- JOURNAL_START -->
	</div>
	<br>

</body>
<script>
	console.log(`Loaded ${new TextEncoder().encode(document.documentElement.outerHTML).length / 1024}Kbs in ${performance.now()-st}ms`)
</script>
</html>
<!-- End of file reached -->
